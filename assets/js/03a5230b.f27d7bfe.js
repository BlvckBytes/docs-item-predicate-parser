"use strict";(self.webpackChunkdocs_item_predicate_parser=self.webpackChunkdocs_item_predicate_parser||[]).push([[221],{131:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>p,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var a=s(4848),n=s(8453);const i={sidebar_position:4},r="Material Predicate",o={id:"expression-syntax/material-predicate",title:"Material Predicate",description:"The material-predicate matches against the type of item, e.g. stone, dirt, enchanted book, diamond pickaxe, etc., and does not take any arguments.",source:"@site/docs/expression-syntax/material-predicate.md",sourceDirName:"expression-syntax",slug:"/expression-syntax/material-predicate",permalink:"/docs-item-predicate-parser/expression-syntax/material-predicate",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"documentationSidebar",previous:{title:"Numeric Arguments",permalink:"/docs-item-predicate-parser/expression-syntax/numeric-arguments"},next:{title:"Amount Predicate",permalink:"/docs-item-predicate-parser/expression-syntax/amount-predicate"}},c={},d=[{value:"Custom Groups",id:"custom-groups",level:2}];function l(e){const t={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",...(0,n.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"material-predicate",children:"Material Predicate"})}),"\n",(0,a.jsx)(t.p,{children:"The material-predicate matches against the type of item, e.g. stone, dirt, enchanted book, diamond pickaxe, etc., and does not take any arguments."}),"\n",(0,a.jsx)(t.h2,{id:"custom-groups",children:"Custom Groups"}),"\n",(0,a.jsxs)(t.p,{children:["In order to specify custom groups of materials, simply add exactly one syllable consiting of a questionmark (",(0,a.jsx)(t.code,{children:"?"}),"), which signals that not only the shortest match should be accepted, but all resulting matches. This notation only works for the material-predicate, for two reasons: firstly, it would be impossible to avoid ambiguity otherwise, and secondly, it doesn't make sense anywhere else. When in this mode, exact matches, meaning targets which do not contain any remaining syllables, are disregarded. If you want to include those, you have to ",(0,a.jsx)(t.a,{href:"/docs-item-predicate-parser/expression-syntax/or-junction",children:"or"})," them in specifically. Let's look at a few examples:"]}),"\n",(0,a.jsxs)(t.p,{children:["Query: glass-?",(0,a.jsx)(t.br,{}),"\n","Matches: stained glass, glass panes, stained glass panes, glass bottles, etc."]}),"\n",(0,a.jsxs)(t.p,{children:["Query: sign-?",(0,a.jsx)(t.br,{}),"\n","Matches: signs (all wood-types), wall-signs (all wood-types)"]}),"\n",(0,a.jsxs)(t.p,{children:["Query: sign-?-!wall",(0,a.jsx)(t.br,{}),"\n","Matches: signs (all wood-types)"]}),"\n",(0,a.jsxs)(t.p,{children:["Query: music-disc-?",(0,a.jsx)(t.br,{}),"\n","Matches: all various music discs"]})]})}function p(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>r,x:()=>o});var a=s(6540);const n={},i=a.createContext(n);function r(e){const t=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),a.createElement(i.Provider,{value:t},e.children)}}}]);