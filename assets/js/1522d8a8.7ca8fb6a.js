"use strict";(self.webpackChunkdocs_item_predicate_parser=self.webpackChunkdocs_item_predicate_parser||[]).push([[170],{6048:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var n=i(4848),s=i(8453);const r={sidebar_position:2},a="Predicate Decision",o={id:"expression-syntax/predicate-decision",title:"Predicate Decision",description:"While it might not be immediately obvious how specific predicate types are decided upon, based on nothing but the aforementioned syllable matching units, the process is rather simple. All existing target identifiers are tested against, which results in a list of matches; the match shortest in length is considered to be the final result. This list of matches is displayed to the user by the means of command completion, while the final result preview is rendered in the action-bar.",source:"@site/docs/expression-syntax/predicate-decision.md",sourceDirName:"expression-syntax",slug:"/expression-syntax/predicate-decision",permalink:"/docs-item-predicate-parser/expression-syntax/predicate-decision",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"documentationSidebar",previous:{title:"Syllables",permalink:"/docs-item-predicate-parser/expression-syntax/syllables"},next:{title:"Numeric Arguments",permalink:"/docs-item-predicate-parser/expression-syntax/numeric-arguments"}},d={},c=[{value:"Arguments",id:"arguments",level:2},{value:"Collision Prefixes",id:"collision-prefixes",level:2}];function l(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"predicate-decision",children:"Predicate Decision"})}),"\n",(0,n.jsx)(t.p,{children:"While it might not be immediately obvious how specific predicate types are decided upon, based on nothing but the aforementioned syllable matching units, the process is rather simple. All existing target identifiers are tested against, which results in a list of matches; the match shortest in length is considered to be the final result. This list of matches is displayed to the user by the means of command completion, while the final result preview is rendered in the action-bar."}),"\n",(0,n.jsx)(t.admonition,{type:"info",children:(0,n.jsxs)(t.p,{children:["Predicates can be stringed together without the use of any logical junctions, as ",(0,n.jsx)(t.a,{href:"/docs-item-predicate-parser/expression-syntax/and-junction",children:"and"})," is always assumed by default - this saves on typing effort and improves readability."]})}),"\n",(0,n.jsx)(t.h2,{id:"arguments",children:"Arguments"}),"\n",(0,n.jsxs)(t.p,{children:["Each final target is aware of it's internal predicate type, which will then be parsed, including it's optional numeric arguments; no predicate ",(0,n.jsx)(t.em,{children:"requires"})," arguments. If they're appended, they will be collected - otherwise, the next predicate may begin immediately afterwards. While there are no argument-types other than numbers, they provide a hand-full of additional features, as can be read up on ",(0,n.jsx)(t.a,{href:"/docs-item-predicate-parser/expression-syntax/numeric-arguments",children:"here"}),"."]}),"\n",(0,n.jsx)(t.h2,{id:"collision-prefixes",children:"Collision Prefixes"}),"\n",(0,n.jsxs)(t.p,{children:["There are many categories, like Material, Enchantment, Potion-Effect, Music-Instrument, etc., and so there may be collisions between identifiers accross groups. A perfect example would be that of the effect ",(0,n.jsx)(t.em,{children:"Strength"})," and the enchantment ",(0,n.jsx)(t.em,{children:"Power"}),", which both translate as ",(0,n.jsx)(t.em,{children:"St\xe4rke"})," into German. The system can no longer distinguish between the predicate type, rendering all but one of the colliding members unusable; to circumvent this, collision-prefixes have been introduced, which are automatically added and hard-coded per language, to ensure uniformity. The previously mentioned case would result in ",(0,n.jsx)(t.code,{children:"[Effekt]-St\xe4rke"})," and ",(0,n.jsx)(t.code,{children:"[Verzauberung]-St\xe4rke"}),"; using them would be as simple as ",(0,n.jsx)(t.code,{children:"eff-st\xe4r"})," or ",(0,n.jsx)(t.code,{children:"verz-st\xe4r"}),". In the highly unlikely and rather unplausible case of collisions within the same group, an incrementing index ",(0,n.jsx)(t.code,{children:"[N]-"})," will be prepended; better safe than sorry."]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>a,x:()=>o});var n=i(6540);const s={},r=n.createContext(s);function a(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);